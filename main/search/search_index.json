{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"contributing/code/","title":"Code","text":""},{"location":"contributing/code/#pre-requisites","title":"Pre-requisites","text":"<p>You will need to have the following installed:</p> <ul> <li>Nix</li> <li>Direnv</li> </ul> <p>Important</p> <p>We use a Flake-based workflow. You can certainly develop for <code>nixos-facter</code> without Flakes and leverage much of what is listed below, but it is left up to the reader to determine how to make that work.</p>"},{"location":"contributing/code/#formatting","title":"Formatting","text":"<p>We use treefmt and treefmt-nix to format the repository by running <code>nix fmt</code> from the root directory.</p> nix/formatter.nix<pre><code>{ pkgs, inputs, ... }:\nlet\n  hasNixFmt = pkgs.lib.meta.availableOn pkgs.stdenv.buildPlatform pkgs.nixfmt-rfc-style.compiler;\nin\ninputs.treefmt-nix.lib.evalModule pkgs {\n  projectRootFile = \".git/config\";\n\n  programs = {\n    nixfmt.enable = hasNixFmt;\n    nixfmt.package = pkgs.nixfmt-rfc-style;\n\n    deadnix.enable = true;\n    prettier.enable = true;\n    statix.enable = true;\n  };\n\n  settings = {\n    global.excludes = [\n      \"LICENSE\"\n      \"*.narHash\"\n      # unsupported extensions\n      \"*.{gif,png,svg,tape,mts,lock,mod,sum,toml,env,envrc,gitignore}\"\n    ];\n\n    formatter = {\n      deadnix = {\n        priority = 1;\n      };\n\n      statix = {\n        priority = 2;\n      };\n\n      nixfmt = pkgs.lib.mkIf hasNixFmt { priority = 3; };\n\n      prettier = {\n        options = [\n          \"--tab-width\"\n          \"4\"\n        ];\n        includes = [ \"*.{css,html,js,json,jsx,md,mdx,scss,ts,yaml}\" ];\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"contributing/code/#checks","title":"Checks","text":"<p>Running <code>nix flake check</code> will build all the devshells and Nix packages, as well as check the formatting with treefmt and any other Flake checks that have been configured.</p>"},{"location":"contributing/code/#documentation","title":"Documentation","text":"<p>When making changes, it is important to add or update any relevant sections in the documentation within the same pull request.</p> <p>For more information see the next section.</p>"},{"location":"contributing/docs/","title":"Documentation","text":"<p>There is a separate devshell called <code>docs</code> which is provided for working with the docs locally.</p> <p>It can be entered by running: <code>nix develop .#docs</code></p> nix/devshells/docs.nix<pre><code>{\n  pkgs,\n  ...\n}:\npkgs.mkShellNoCC {\n  packages =\n    let\n      inherit (pkgs) lib;\n\n      # Capture root so we can identify our store paths below\n      root = toString ./.;\n\n      snakeCase = with lib; replaceStrings upperChars (map (s: \"_\" + s) lowerChars);\n\n      # Eval Facter module\n      eval = lib.evalModules {\n        modules = [\n          # Load the root module\n          ./modules/nixos/facter.nix\n          {\n            # Disable checks so it doesn't complain about NixOS related options which aren't available\n            config._module.check = false;\n            # Use the basic vm's report\n            config.facter.reportPath = ./hosts/basic/report.json;\n          }\n        ];\n      };\n\n      # Convert `/nix/store/...` store paths in the option declarations into a repository link.\n      # NOTE: we point at the main branch, but for versioned docs this will be incorrect.\n      # It's still a good starting point though.\n      transformDeclaration =\n        decl:\n        let\n          declStr = toString decl;\n          subpath = lib.removePrefix \"/\" (lib.removePrefix root declStr);\n        in\n        assert lib.hasPrefix root declStr;\n        {\n          url = \"https://github.com/numtide/nixos-facter-modules/blob/main/${subpath}\";\n          name = subpath;\n        };\n\n      # Convert options into options doc, transforming declaration paths to point to the github repository.\n      nixosOptionsDoc =\n        _name: options:\n        pkgs.nixosOptionsDoc {\n          inherit options;\n          transformOptions =\n            opt:\n            opt\n            // {\n              declarations = map transformDeclaration opt.declarations;\n            };\n        };\n\n      # Take an options attr set and produce a markdown file.\n      mkMarkdown =\n        name: options:\n        let\n          optionsDoc = nixosOptionsDoc name options;\n        in\n        pkgs.runCommand \"${name}-markdown\" { } ''\n          mkdir $out\n          cat ${optionsDoc.optionsCommonMark} &gt; $out/${snakeCase name}.md\n        '';\n\n      facterMarkdown = mkMarkdown \"facter\" eval.options.facter.detected;\n      otherMarkdown = lib.mapAttrsToList mkMarkdown (\n        lib.filterAttrs (n: _v: n != \"detected\") eval.options.facter\n      );\n\n      optionsMarkdown = pkgs.symlinkJoin {\n        name = \"facter-module-markdown\";\n        paths = [ facterMarkdown ] ++ otherMarkdown;\n      };\n\n    in\n    [\n      (pkgs.writeScriptBin \"mkdocs\" ''\n        # rsync in NixOS modules doc to avoid issues with symlinks being owned by root\n        rsync -aL --chmod=u+rw --delete-before ${optionsMarkdown}/ ./docs/content/reference/nixos_modules\n\n        # execute the underlying command\n        ${pkgs.mkdocs}/bin/mkdocs \"$@\"\n      '')\n    ]\n    ++ (with pkgs.python3Packages; [\n      mike\n      mkdocs-material\n    ]);\n}\n</code></pre> <p>The docs are based on MkDocs and the MkDocs Material theme. You will find its configuration and content in the following locations:</p> <ul> <li><code>mkdocs.yaml</code></li> <li><code>./docs</code></li> </ul>"},{"location":"contributing/docs/#serve-locally","title":"Serve locally","text":"<p>To serve the docs locally run <code>mkdocs serve</code> from the root of the repository:</p> <pre><code>\u276f mkdocs serve\nINFO    -  Building documentation...\nINFO    -  Cleaning site directory\nWARNING -  The following pages exist in the docs directory, but are not included in the \"nav\" configuration:\n             - index.md\nINFO    -  Documentation built in 0.26 seconds\nINFO    -  [16:22:36] Watching paths for changes: 'docs/content', 'mkdocs.yml'\nINFO    -  [16:22:36] Serving on http://127.0.0.1:8000/nixos-facter/\n</code></pre>"},{"location":"contributing/docs/#versioning-publication","title":"Versioning &amp; Publication","text":"<p>Versioning of the docs is managed through mike.</p> <p>It is responsible for managing the structure of the <code>gh-pages</code> branch in the repository, which Github Pages is configured to serve from.</p> <p>Note</p> <p>More information about versioning with MkDocs Material and mike can be found here.</p> <p>There is a github workflow, <code>.github/workflows/gh-pages.yml</code> which is responsible for publishing the docs. It does the following:</p> <ul> <li>On merge to <code>main</code>, the docs version main is updated.</li> <li>When a new tag is created of the form <code>v.&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code> a docs version <code>v&lt;major&gt;.&lt;minor&gt;</code> is created and the     latest alias is updated to point to this.</li> </ul> <p>The idea is that users will land on the latest released version of the docs by default, with <code>main</code> being available if they wish to read about unreleased features and changes.</p> <p>To preview the versions locally you can use <code>mike serve</code> instead of <code>mkdocs serve</code>.</p> <p>Warning</p> <p>Be sure to have fetched the latest changes for the <code>gh-pages</code> branch first. This is especially important if you are using <code>mike</code> locally to make manual changes to the published site.</p>"},{"location":"getting-started/generate-report/","title":"Generate a report","text":"<p>To generate a report, you will need to have Nix installed on the target machine.</p> FlakeNixpkgs <pre><code>sudo nix run \\\n  --option experimental-features \"nix-command flakes\" \\\n  --option extra-substituters https://numtide.cachix.org \\\n  --option extra-trusted-public-keys numtide.cachix.org-1:2ps1kLBUWjxIneOy1Ik6cQjb41X0iXVXeHigGmycPPE= \\\n  github:numtide/nixos-facter -- -o facter.json\n</code></pre> <p>Warning</p> <p>The latest report output from <code>main</code> may be incompatible. Run from nixpkgs to ensure a stable report output.</p> <pre><code>sudo nix run nixpkgs#nixos-facter -- -o facter.json\n</code></pre> <p>This will scan your system and produce a JSON-based report in a file named <code>facter.json</code>:</p> facter.json<pre><code>{\n  \"version\": 2, // (1)!\n  \"system\": \"x86_64-linux\", // (2)!\n  \"virtualisation\": \"none\", // (3)!\n  \"hardware\": { // (4)!\n    \"bios\": { ... },\n    \"bluetooth\": [ ... ],\n    \"bridge\": [ ... ],\n    \"chip_card\": [ ... ] ,\n    \"cpu\": [ ... ],\n    \"disk\": [ ... ],\n    \"graphics_card\": [ ... ],\n    \"hub\": [ ... ],\n    \"keyboard\": [ ... ],\n    \"memory\": [ ... ],\n    \"monitor\": [ ... ],\n    \"mouse\": [ ... ],\n    \"network_controller\": [ ... ],\n    \"network_interface\": [ ... ],\n    \"sound\": [ ... ],\n    \"storage_controller\": [ ... ],\n    \"system\": [ ... ],\n    \"unknown\": [ ... ],\n    \"usb_controller\": [ ... ]\n  },\n  \"smbios\": { // (5)!\n    \"bios\": { ... },\n    \"board\": { ... },\n    \"cache\": [ ... ],\n    \"chassis\": { ... },\n    \"config\": { ... },\n    \"language\": { ... },\n    \"memory_array\": [ ... ],\n    \"memory_array_mapped_address\": [ ... ],\n    \"memory_device\": [ ... ],\n    \"memory_device_mapped_address\": [ ... ],\n    \"memory_error\": [ ... ],\n    \"onboard\": [ ... ],\n    \"port_connector\": [ ... ],\n    \"processor\": [ ... ],\n    \"slot\": [ ... ],\n    \"system\": { ... }\n  }\n}\n</code></pre> <ol> <li>Used to track major breaking changes in the report format.</li> <li>Architecture of the target machine.</li> <li>Indicates whether the report was generated inside a virtualised environment, and if so, what type.</li> <li>All the various bits of hardware that could be detected.</li> <li>System Management BIOS information if available.</li> </ol>"},{"location":"getting-started/nixos-configuration/","title":"NixOS Configuration","text":"<p>Taking the <code>facter.json</code> file generated in the previous step, we can construct a NixOS configuration:</p> FlakeNon-Flake flake.nix<pre><code>{\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    nixos-facter-modules.url = \"github:numtide/nixos-facter-modules\";\n  };\n\n  outputs =\n    inputs@{ nixpkgs, ... }:\n    let\n        inherit (nixpkgs) lib;\n    in\n    {\n      nixosConfigurations.basic = lib.nixosSystem {\n        modules = [\n\n          # enable the NixOS Facter module\n          inputs.nixos-facter-modules.nixosModules.facter\n\n          # configure the facter report\n          { config.facter.reportPath = ./facter.json; }\n\n          # Additional modules and configuration, for example:\n          #\n          # {\n          #   users.users.root.initialPassword = \"fnord23\";\n          #   boot.loader.grub.devices = lib.mkForce [ \"/dev/sda\" ];\n          #   fileSystems.\"/\".device = lib.mkDefault \"/dev/sda\";\n          # }\n          # ...\n          # Define your bootloader if you are not using grub\n          # { boot.loader.systemd-boot.enable = true; }\n        ];\n      };\n    };\n}\n</code></pre> configuration.nix<pre><code>{ lib, ... }:\n{\n  imports = [\n    \"${\n      (builtins.fetchTarball { url = \"https://github.com/numtide/nixos-facter-modules/\"; })\n    }/modules/nixos/facter.nix\"\n  ];\n\n  # configure the facter report\n  config.facter.reportPath = ./facter.json;\n\n  # Additional modules and configuration, for example:\n  #\n  # config.users.users.root.initialPassword = \"fnord23\";\n  # config.boot.loader.grub.devices = lib.mkForce [ \"/dev/sda\" ];\n  # config.fileSystems.\"/\".device = lib.mkDefault \"/dev/sda\";\n  #\n  # ...\n  # Define your bootloader if you are not using grub\n  # config.boot.loader.systemd-boot.enable = true;\n}\n</code></pre> <p>The NixOS Facter module will attempt to do the following:</p> <ul> <li>Configure <code>nixpkgs.hostPlatform</code> based on the detected architecture.</li> <li>Enable a variety of kernel modules and NixOS options related to VM and bare-metal environments based on the detected virtualisation.</li> <li>Enable CPU microcode updates based on the detected CPU(s).</li> <li>Ensure a variety of kernel modules are made available at boot time based on the detected (usb|firewire|storage) controllers and disks.</li> <li>Enable a variety of kernel modules based on the detected Broadcom and Intel WiFi devices.</li> </ul> <p>Roadmap</p> <p>We continue to add to and improve nixos-facter-modules. Our eventual goal is to replace much if not all of the functionality currently provided by nixos-hardware and nixos-generate-config.</p>"}]}